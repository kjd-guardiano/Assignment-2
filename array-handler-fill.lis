     1                                  ;Array Handler - Fill
     2                                  ;Katherine Joy Guardiano, 240-3
     3                                  
     4                                  ; ==== Code Area Start ====
     5                                  global fillarray
     6                                  extern scanf ;for calling the function scanf
     7                                  extern printf ;for calling the function printf
     8                                  
     9                                  segment .data
    10                                  ; ==== Data Declarations ====
    11 00000000 456E74657220666C6F-     msg db "Enter float numbers separated by white space. After last number, enter white space followed by CTRL+D.", 10, 0
    11 00000009 6174206E756D626572-
    11 00000012 732073657061726174-
    11 0000001B 656420627920776869-
    11 00000024 74652073706163652E-
    11 0000002D 204166746572206C61-
    11 00000036 7374206E756D626572-
    11 0000003F 2C20656E7465722077-
    11 00000048 686974652073706163-
    11 00000051 6520666F6C6C6F7765-
    11 0000005A 64206279204354524C-
    11 00000063 2B442E0A00         
    12 00000068 4E756D626572207265-     receivemsg db "Number received: %lf", 10, 0
    12 00000071 6365697665643A2025-
    12 0000007A 6C660A00           
    13 0000007E 526561636865642065-     endoffillmsg db "Reached end of fill.", 10, 0
    13 00000087 6E64206F662066696C-
    13 00000090 6C2E0A00           
    14                                  
    15                                  ; ==== Format Declarations ====
    16 00000094 256C6600                floatform db "%lf", 0 ;8-byte float format
    17 00000098 25372E346C6620372E-     arrayform db "%7.4lf 7.4lf 7.4lf", 10, 10, 0
    17 000000A1 346C6620372E346C66-
    17 000000AA 0A0A00             
    18                                  
    19                                  segment .bss
    20                                  ;example only
    21                                  align 64
    22                                  ;backup resb 832
    23                                  ;number_input resq 8
    24                                  
    25                                  segment .text
    26                                  ; ==== Start of Code ====
    27                                  ; ==== Start of Backup ====
    28 00000000 55                      push       rbp                                              ;Save a copy of the stack base pointer
    29 00000001 4889E5                  mov        rbp, rsp                                         ;We do this in order to be 100% compatible with C and C++.
    30 00000004 53                      push       rbx                                              ;Back up rbx
    31 00000005 51                      push       rcx                                              ;Back up rcx
    32 00000006 52                      push       rdx                                              ;Back up rdx
    33 00000007 56                      push       rsi                                              ;Back up rsi
    34 00000008 57                      push       rdi                                              ;Back up rdi
    35 00000009 4150                    push       r8                                               ;Back up r8
    36 0000000B 4151                    push       r9                                               ;Back up r9
    37 0000000D 4152                    push       r10                                              ;Back up r10
    38 0000000F 4153                    push       r11                                              ;Back up r11
    39 00000011 4154                    push       r12                                              ;Back up r12
    40 00000013 4155                    push       r13                                              ;Back up r13
    41 00000015 4156                    push       r14                                              ;Back up r14
    42 00000017 4157                    push       r15                                              ;Back up r15
    43 00000019 9C                      pushf                                                       ;Back up rflags
    44                                  ; ==== End of Backup ====
    45                                  fillarray:
    46 0000001A 4989FE                  mov r14, rdi ;backs up incoming data, r14 is the array
    47 0000001D 4989F7                  mov r15, rsi ;r15 is # of cells
    48                                  
    49                                  ;Block for message output.
    50 00000020 B800000000              mov rax, 0 ;rax is a known register, counts # of float registers
    51 00000025 48BF-                   mov rdi, msg
    51 00000027 [0000000000000000] 
    52 0000002F 50                      push rax
    53 00000030 E8(00000000)            call printf
    54 00000035 58                      pop rax
    55                                  
    56 00000036 4D31ED                  xor r13, r13 ;places a 0 within register r13, acts as index; when r13 == 15, array is full
    57                                  
    58                                  begin:
    59 00000039 4D39FD                  cmp r13, r15
    60 0000003C 742C                    je done ;if r13 > r15, exit
    61                                  
    62 0000003E B800000000              mov rax, 0
    63 00000043 48BF-                   mov rdi, floatform
    63 00000045 [9400000000000000] 
    64 0000004D 6A00                    push qword 0
    65 0000004F 4889E6                  mov rsi, rsp
    66 00000052 E8(00000000)            call scanf
    67 00000057 4158                    pop r8
    68                                  
    69                                  ;check for CTRL+D first, places -1 in eax
    70 00000059 4898                    cdqe ;rax will fill with whatever is in eax, does NOT have parameters
    71 0000005B 4883F8FF                cmp rax, -1
    72 0000005F 7409                    je done ;jumps ONLY if equal to "done"
    73                                  
    74                                  ;pop rbx ;causes a seg fault when included, for some reason?
    75 00000061 4F8904EE                mov [r14 + r13*8], r8 ;8 represents one cell
    76                                  
    77 00000065 49FFC5                  inc r13
    78                                  
    79 00000068 EBCF                    jmp begin
    80                                  
    81                                  done:
    82 0000006A 4C89E8                  mov rax, r13 ;rax is the only register that can move an integer back to caller
    83                                  
    84                                  ; ==== Start of Restore ====
    85 0000006D 9D                      popf
    86 0000006E 415F                    pop  r15
    87 00000070 415E                    pop  r14
    88 00000072 415D                    pop  r13
    89 00000074 415C                    pop  r12
    90 00000076 415B                    pop  r11
    91 00000078 415A                    pop  r10
    92 0000007A 4159                    pop  r9
    93 0000007C 4158                    pop  r8
    94 0000007E 5E                      pop  rsi
    95 0000007F 5F                      pop  rdi
    96 00000080 5A                      pop  rdx
    97 00000081 59                      pop  rcx
    98 00000082 5B                      pop  rbx
    99 00000083 5D                      pop  rbp
   100                                  ; ==== End of Restore ====
   101 00000084 C3                      ret
   102                                  ; ==== End of Code ====
